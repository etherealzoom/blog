[{"content":"疑惑 Pytorch平台上对RWKV的困惑度计算模块进行量化的经历 Q:更稳妥的方式是在模型加载和量化后，将整个模型转为float32，再量化后转换成float32的目的是什么呢，这样不是把原来量化好的给毁了吗\nA：\npytorch上量化做了什么 当调用torch.quantization.quantize_dynamic时，PyTorch并不仅仅是把权重张量的数据类型（dtype）改了一下。它做了一件更根本的事：它将模型中的标准nn.Linear层替换成了一个全新的、专门的模块，叫做DynamicQuantizedLinear。\n在这个新的DynamicQuantizedLinear模块内部，权重确实被压缩并以**torch.qint8（8位整型）**的格式存储了起来。\n同时，这个模块还保存了将这些INT8整数反量化回浮点数所需的缩放因子（scale）和零点（zero-point）（它们是浮点数）。\n.to(torch.float32) 到底做了什么？ 当您对一个模型调用.to(dtype)方法时，PyTorch会遍历模型的所有参数（parameters）和缓冲区（buffers），并尝试将它们的类型转换为您指定的dtype。\n这里的关键在于：.to() 方法只会转换浮点类型的张量（例如 bfloat16, float16, float64）。\n它会跳过那些已经是**整型（Integer）**的张量，比如我们量化后存储为torch.qint8的权重。 因此，INT8权重本身保持不变，量化的成果得以保留。\n那我们为什么要执行这个转换呢？ 这个操作的目的，正是为了解决您在上一个问题中遇到的 RuntimeError: expected scalar type Float but found BFloat16 错误。\n让我们回顾一下当时的情况：\n(1)原始模型：您加载模型时，因为设置了'dataformat': 'bf16'，所以模型中所有的浮点参数都是bfloat16类型。这包括Embedding层、LayerNorm层，以及Linear层的权重和偏置。 (2)量化之后：quantize_dynamic函数只替换了Linear层。但是，模型中的其他层（如Embedding和LayerNorm）的参数依然是bfloat16类型。 (3)冲突发生：当数据流经模型时，Embedding层输出一个bfloat16的张量，这个张量被送入到我们新替换的DynamicQuantizedLinear层。然而，这个量化层的CPU后端实现期望接收一个标准的float32张量作为输入，而不是bfloat16。于是，类型不匹配，程序崩溃。\n所以，调用model.to(torch.float32)的真正目的，是将模型中除了INT8权重之外的所有其他浮点参数和缓冲区**（比如仍然是bfloat16格式的Embedding层或LayerNorm层）全部统一转换为标准的float32格式。\n总结一下，这个操作可以理解为一次“内务整理”：\nINT8权重： untouchable，保持量化状态。 其他所有浮点部分（bfloat16）：全部转换为float32。 这样一来，整个模型的数据流就统一了：非量化层输出float32张量，量化层接收float32张量，内部进行计算，从而完美解决了类型冲突的问题，同时保留了INT8量化带来的内存节省优势。\npython中的enumereate (1) 没有 enumerate 的情况 您的原始循环是这样的： for begin_loc in tqdm(range(0, 1536, 512)):\n这个循环会执行三次，在每一次循环中：\n第1次循环：begin_loc 的值是 0 第2次循环：begin_loc 的值是 512 第3次循环：begin_loc 的值是 1024 可以看到，这个循环只提供了一个变量 begin_loc。\n(2) 加入 enumerate 之后的情况\n您修改后的正确循环是这样的： for idx, begin_loc in enumerate(tqdm(range(0, 1536, 512))):\n这个循环同样会执行三次，在每一次循环中：\n第1次循环：idx 的值是 0，begin_loc 的值是 0 第2次循环：idx 的值是 1，begin_loc 的值是 512 第3次循环：idx 的值是 2，begin_loc 的值是 1024 结论 通过对比可以清晰地看到：\n核心变量 begin_loc 的值完全没变：在每次对应的循环中，begin_loc 得到的值和原来一模一样，都是 0, 512, 1024, ...。所以您循环内部使用 begin_loc 的所有逻辑都不会受到任何影响。\n循环次数完全没变：range 函数生成多少个数字，循环就会执行多少次。enumerate 不会增加或减少循环的次数。\n唯一的改变：enumerate 只是为您额外提供了一个从0开始的计数器变量 idx。这个变量正是您在 print 语句中所需要的，它解决了 NameError，并且让您能方便地知道当前是第几步循环。\n所以，加入 enumerate 是一个纯粹的“增强”操作，它在不干扰原有功能的基础上，安全地添加了您需要的新功能（即步数索引）。这是在Python中进行带索引循环的标准且推荐的做法。\n如果计算RWKV中的困惑度的呢 核心思想是**“对比每一个字（Token）的输出与下一个真实字的关系”**\nRWKV的困惑度计算的核心代码（先计算loss）：\nwith torch.no_grad(): logits, state = model.forward_parallel_slices(input, state, slice_len=1024) loss = F.cross_entropy(logits.view(-1, logits.size(-1)), output) 只进行推理计算，不计算梯度 二者有什么区别吗 训练是为了教会模型，而推理是为了使用已经教好的模型\n当然有，这两种模式在计算流程、资源消耗和最终目的上有着本质的区别。\n简单来说，训练是为了教会模型，而推理是为了使用已经教好的模型。\n特性 (Characteristic) 训练模式 (Training Mode) 推理模式 (Inference Mode) 核心目标 学习和优化模型参数（权重），让模型变得更“聪明”。 使用已训练好的模型对新数据进行预测和评估。 计算流程 前向传播 + 反向传播 (Forward Pass + Backward Pass) 仅有前向传播 (Forward Pass ONLY) 梯度计算 必须计算梯度。梯度是反向传播的核心，它告诉每个权重应该如何调整才能减小误差（loss）。 完全不需要计算梯度。因为模型参数是固定的，我们不打算更新它，所以计算梯度就成了不必要的开销。 内存占用 高。为了能够进行反向传播，PyTorch需要构建一个“计算图”，并保存所有中间步骤的计算结果（激活值）。这会占用大量内存。 低。因为不需要反向传播，PyTorch可以用完一个中间结果后立即丢弃，无需为计算图保存任何额外信息，大大节省了内存。 计算速度 慢。既要跑一遍前向传播，又要跑一遍更复杂的反向传播。 快。只执行一次前向传播，省去了所有与梯度相关的计算。 在PyTorch中的体现 默认模式。执行loss.backward()和optimizer.step()来更新权重。 使用with torch.no_grad():代码块包裹。同时常配合model.eval()来关闭Dropout等只在训练时使用的层。 因此，在计算困惑度时，使用 with torch.no_grad(): 是一个重要的优化步骤，它能让评估过程变得更快、更节省资源。\n","date":"2025-07-09T23:06:03+08:00","permalink":"https://etherealzoom.github.io/blog/p/quantization/","title":"Quantization"},{"content":"玄戒O1芯片架构 芯片基础 CPU: 基于ARMv9.2指令集架构的Cortex CPU集群\nGPU: ARM的Immortalis GPU IP\n系统级设计: 玄戒O1芯片的互联技术采用了ARM的CoreLink系统IP CPU架构 十核四丛集设计\nCortex-X925 3.9GHz *2\n-\u0026gt; 最高主频达3.9GHz，表现超越业界标准设计，是小米玄戒团队通过大量创新和数百次版图迭代优化的结果\nCortex-A725 3.4GHz *4\nCortex-A725 1.9GHz *2\nCortex-A520 1.8GHz *2\nUltra-fast Micro Control Unit-on chip\n在硬件上实现对各个核的调度\n缓存结构\n数据保存的位置离使用的位置越近，性能越高，降低延迟核功耗\n玄戒团队三个提高主频的方法\n(1) 优化供电网络设计：边缘供电+空间组网\n玄戒团队将主供电单元移到SoC两侧，缩短逻辑单元的物理距离\n(2) 自研多种3nm标准单元Std Cell\n(3) 电路版图全链路迭代优化+人工精调\nNPU 玄戒O1内置6核NPU，集成Scalar标量加速器、Vector矢量加速器和Tensor张量加速器，NPU算力可达44 TOPS ，支持多算法并行计算。在拍摄时，可并行“拍照”和“预览”算法，不仅满足计算摄影的影像算法需求，更针对小米自有的端侧模型进行了硬件底层的深度定制。\n配合全新第三代小米端侧模型，AI处理速度更快，同时功耗更低，使手机在智能语音助手、图像识别、智能场景优化等AI应用方面表现更加出色。\nISP xiaomi自研第四代ISP单元\n芯片设计开发流程 Total 定义与架构设计 -\u0026gt;\nDesign, Verification, Logic Synthesis, STA, DFT (前端设计) -\u0026gt;\n版图规划, 布局布线, 寄生参数提取和时序分析, 版图物理验证 (后端设计) -\u0026gt;\n生成GDSII文件, Tape-out流片\n第一阶段：定义与架构设计（前端设计的起点） 这是将市场需求转化为技术规格的阶段，决定了芯片“做什么”和“怎么做”。\n1. 市场需求与规格定义 (Specification)\n一切始于一个问题：“我们要做一颗什么样的芯片？” 产品经理和市场团队会根据目标应用提出需求，定义芯片需要达到的核心指标，即PPA：\n性能 (Performance)：例如，CPU主频要达到多少GHz，AI算力要达到多少TOPS。 功耗 (Power)：待机功耗、峰值功耗的上限是多少毫瓦。 面积 (Area)：芯片的物理尺寸有多大，这直接关系到成本。 最终会输出一份详尽的《产品规格说明书》。\n2. 架构设计 (Architecture Design)\n选择核心IP：是自研CPU/GPU，还是向ARM、Synopsys等公司购买现成的IP核？ 划分功能模块：将芯片划分为不同的功能单元，如计算模块、存储模块、接口模块（USB, PCIe）等。 设计总线结构：确定这些模块之间如何高效地通信。 建立系统模型：使用SystemC等语言对整个系统进行建模和仿真，初步验证架构的可行性，并对PPA进行早期评估。 第二阶段：数字前端设计与验证（从想法到代码） 这是将架构思想转化为具体硬件描述代码，并确保其功能正确性的核心阶段。在整个芯片开发中，验证占据了约70%的时间和资源，其重要性不言而喻。\n1. RTL设计 (Register-Transfer Level Design)\n使用HDL(Verilog等)，将每个模块的具体功能以代码形式描述出来。\nRTL是一种设计思想和抽象层次, 描述的是数据在寄存器之间的流动和处理方式。\n将一个复杂的数字系统，看作是一系列在时钟信号驱动下，数据在寄存器之间进行传输和处理的过程。它描述了在某个时间点，什么数据，从哪里，经过什么运算，传送到了哪里。\nHDL是将RTL思想用一种标准化的代码形式写出来。s\n2. 功能验证 (Functional Verification)\n验证工程师用尽一切办法证明RTL设计是错误的直至没有错误。\n搭建验证平台：使用SystemVerilog和UVM等行业标准，建立一个复杂的测试环境。 编写测试用例：通过定向测试和随机测试，模拟各种可能的用户场景和极端（Corner Case）条件。 仿真与调试：在EDA仿真工具（如Synopsys VCS, Cadence Xcelium）中运行测试用例，将RTL代码的输出与预期结果进行比对，找出并修复Bug。这是一个漫长且不断迭代的过程。 3. 逻辑综合 (Logic Synthesis)\n验证通过的RTL代码，需要从行为描述转化为实际的电路结构。逻辑综合工具（如Synopsys Design Compiler）会自动将RTL代码翻译成门级网表（Gate-Level Netlist）。在此阶段，需要设定时序、功耗和面积的约束，工具会尽力在满足这些约束的前提下进行优化。\n4. 静态时序分析 (STA) 与等价性检查\n静态时序分析：确保信号能在时钟的驱动下，在指定的时间内从一个触发器稳定地传到下一个触发器，满足时序要求。 等价性检查：形式化验证的一种，确保综合后的门级网表在逻辑功能上与原始的RTL代码完全一致。 STA 的核心目标是：确保芯片能跑得够快。\n它是一种验证方法，用于检查数字电路中的所有信号是否能在规定的时间内，从一个寄存器（触发器）稳定地传输到下一个寄存器，从而满足芯片的设计频率要求。\n工作方式：STA 工具会分析电路中成千上万条逻辑路径，计算信号在每条路径上的传输延迟。它不关心信号的具体逻辑功能（是0还是1），只关心信号的传播速度。 检查内容： 建立时间违例 (Setup Violation)：信号到达得太慢了，在下一个时钟周期到来时还没准备好，会导致数据采样错误。这是决定芯片最高能跑多快的关键。 保持时间违例 (Hold Violation)：信号变化得太快了，旧数据没保持足够长的时间，干扰了新数据的稳定，同样会导致错误。 地位：STA 是数字后端设计（物理设计）流程中的关键“签核 (Sign-off)”步骤之一。只有通过了 STA，才能确保芯片的时序性能达标。 5. 可测试性设计DFT (Design For Testability)\nDFT的核心目标是：确保芯片造出来之后是“好”的还是“坏”的，并且能快速地找出的坏点。一颗芯片包含数十亿个晶体管，在制造过程中，难免会出现各种微小的物理缺陷（如短路、断路）。如果不对芯片进行测试，就无法保证交付给客户的产品是功能完好的。\nDFT 就是在设计阶段，预先在电路中植入一些额外的“测试专用”逻辑，使得芯片在生产出来后，能够方便、高效地被自动化测试设备（ATE）进行大规模测试。\n可以把 DFT 想象成给一个复杂的建筑物预先设计好了检修通道和传感器接口：\n工作方式：DFT工程师会在芯片中插入“扫描链（Scan Chains）”，将成千上万个内部的寄存器连接成一条或多条长长的“串珠”，这样测试设备就可以像移位寄存器一样，从外部灌入测试码，并读出内部状态，极大地提高了内部节点的可控性和可观测性。 主要技术： 扫描链设计 (Scan Chain)：将内部状态“暴露”出来。 内建自测试 (BIST, Built-in Self-Test)：让芯片的一部分电路（如内存）能够自己测试自己，生成测试码并验证结果。 自动测试码生成 (ATPG)：使用工具自动生成能够最大程度覆盖各种潜在物理缺陷的测试码。 地位：DFT 是连接设计与制造和量产的关键环节。好的 DFT 设计能显著降低测试成本、提高产品良率、并帮助快速定位失效原因。 ASIC 与 FPGA 的岔路口\nASIC：我们目前描述的流程主要针对ASIC。它的目标是设计一款功能固定、性能和功耗最优的定制芯片，适用于大规模量产。 FPGA：如果项目追求快速上市或产量不大，可以选择FPGA。FPGA内部有预先制造好的逻辑单元和布线资源。其流程在RTL和功能验证后，跳过了复杂的物理设计，直接使用FPGA厂商（如Xilinx/AMD）提供的工具进行综合、布局布线，并生成一个Bitstream烧录到芯片中。开发周期短、成本低，但性能和功耗通常不如同等功能的ASIC。 第三阶段：数字后端设计/物理设计（从代码到版图） 这是将抽象的门级网表转化为具体的、可供制造的物理版图的过程，是连接设计与制造的桥梁。\n1. 版图规划 (Floorplanning)\n规划芯片的宏观布局，包括确定芯片的核心区域大小，放置IO引脚，以及摆放CPU、SRAM等大型模块的预留位置。\n2. 布局与布线 (Placement \u0026amp; Routing)\n布局：EDA工具（如Synopsys IC Compiler, Cadence Innovus）会将数百万个标准逻辑单元精确地放置到规划好的区域内。 时钟树综合 (CTS)：生成一个能将时钟信号同步、低延迟地传送到芯片上所有触发器的网络。 布线：用金属导线将所有单元根据网表的连接关系连接起来。 3. 签核 (Sign-off)\n在将最终设计成果交付给晶圆厂之前，必须进行一系列严格的最终检查，确保万无一失。这个过程被称为“签核”。\nDRC (设计规则检查)：确保版图符合晶圆厂的制造工艺规则，比如导线最小宽度、最小间距等。 LVS (版图与原理图对比)：确保最终版图的电路连接关系与综合后的门级网表完全一致。 寄生参数提取与时序分析：从版图中提取实际的电阻、电容等寄生参数，进行最终的、最精确的静态时序分析，确保芯片在实际物理效应下依然满足性能要求。 当所有检查都通过后，设计数据（GDSII）将被正式“流片（Tape-out）”，传送给芯片代工厂。\n关于模拟电路设计\n值得一提的是，SoC中通常还包含模拟电路（如电源管理、锁相环PLL、数模转换器ADC等）。模拟电路的设计流程与数字电路截然不同，它更像一门“艺术”，高度依赖工程师的经验。其设计过程以晶体管级的电路图设计和SPICE仿真为主，版图设计通常需要手动绘制，对寄生效应极其敏感，是一个不断仿真、调整、再仿真的迭代过程。\n第四阶段：制造、封测与验证 1. 芯片制造 (Fabrication) 晶圆厂接手GDSII数据后，开始在纯净的硅晶圆上，通过光刻、刻蚀、离子注入、薄膜沉积等数百道极其复杂的工序，层层叠加，最终形成设计好的电路结构。这个过程通常需要数月时间。\n2. 封装与测试 (Packaging \u0026amp; Testing) 制造完成的晶圆会被切割成一个个独立的芯片裸片Die。\n封装：将脆弱的裸片固定在基板上，并连接好与外部电路板通信的引脚，最后用绝缘外壳保护起来，形成我们日常见到的芯片模样。 测试：对封装好的芯片进行功能和性能测试，剔除在制造或封装过程中产生的次品。 3. 投产后验证 (Post-Silicon Validation)\n第一批流片回来的芯片会被送到实验室，在真实的硬件环境中进行上电和测试。这个阶段旨在发现那些在仿真环境中难以暴露的、与真实物理世界交互的Bug，并对芯片的各项性能指标进行最终的实测验证。\n经过这一系列严苛的流程，一颗合格的芯片才算真正诞生，准备投入大规模生产，并最终进入到消费者的电子产品中。\nReferences.\n[1] 极客湾\n[2] 老石谈芯\n","date":"2025-07-09T21:56:37+08:00","permalink":"https://etherealzoom.github.io/blog/p/%E4%BB%8Exring-o1%E8%AF%B4%E5%BC%80%E6%9D%A5/","title":"从Xring O1说开来"},{"content":"常用命令 # 初始化一个本地仓库 git init # 添加所有文件到暂存区 git add . # 提交暂存区的文件到本地仓库，并添加一条提交信息 git commit -m \u0026#34;first commit\u0026#34; # 添加一个远程仓库的地址，命名为origin git remote add origin https://github.com/user/repo.git # 将本地仓库的内容推送到远程仓库的master分支 git push -u origin master #查看当前缓存区的all内容 git ls-files #上传文件夹里面的所有文件，添加子文件夹及其内容至暂存区 使用`git add`命令，配合递归通配符`**`来添加子文件夹及其内部的所有文件。假设子文件夹名为`subfolder`，执行： git add subfolder/** /**/ #delete a cangku 的所有提交记录 #查看当前分支数量以及名称 git branch #创建一个新的孤立分支，并切换到该分支 git checkout --orphan latest_branch #删除原来的master分支 git branch -D master #重命名当前分支为main git branch -m main #强制推送当前分支到远程仓库, 覆盖原仓库的所有东西且**该操作不可逆** git push -f origin main Git用户资料 //显示差异摘要（每个提交修改的文件及行数统计）： git log --author=\u0026#34;当前用户名\u0026#34; --stat //以图形化方式展示分支历史 git log --author=\u0026#34;当前用户名\u0026#34; --graph //- 显示完整的提交消息： git log --author=\u0026#34;当前用户名\u0026#34; --pretty=format:\u0026#34;%h %s\u0026#34; git文件恢复 //没有add的文件恢复，一个一个恢复 git checkout \u0026lt;文件名\u0026gt; //有add，无commit git checkout \u0026lt;commit id\u0026gt; 文件名 #id使用git log查看 //已经commit git checkout \u0026lt;commit id\u0026gt; 文件名 知识点\n哈希值 f7cafda (HEAD -\u0026gt; master) 重新提交有关tc264开发的相关资料 d01e0e1 提交有关tc264开发的相关资料 前面的一串数字是什么意思 答： 前面的一串数字是哈希值，它是一个由 40 个十六进制字符组成的字符串，用来唯一标识每一次提交。 Git 通过计算提交的内容、作者、日期等信息的 SHA-1 散列值来生成这个哈希值 (HEAD -\u0026gt; master)是什么 答： (HEAD -\u0026gt; master)是Git中的一种表示方式，它表示HEAD指向master分支，而master分支指向最新的提交。HEAD是一个特殊的引用，它总是指向当前的提交，而master是一个普通的分支，它可以指向任何一个提交。当你在master分支上进行提交时，HEAD和master都会移动到最新的提交上(https://zhuanlan.zhihu.com/p/40001702) [1]关于Git分支中HEAD和Master的理解(https://zhuanlan.zhihu.com/p/40001702)[: 关于Git分支中HEAD和Master的理解 - 知乎](https://www.jianshu.com/p/4219b6f62ce3) 解释git push -u origin master git是一个分布式版本控制系统，可以用来管理和协作项目的源代码。\npush是一个git子命令，它的作用是将本地仓库的内容推送到远程仓库的指定分支。\n-u是一个参数，它的全称是–set-upstream，它的作用是设置默认的上游分支，也就是当你在本地仓库执行git pull或git push时，不需要指定远程仓库和分支名，git会自动使用你设置的上游分支。\norigin是一个远程仓库的名称，它是git默认给你添加的远程仓库的别名，你可以使用git remote命令来查看或修改你的远程仓库的名称。\nmaster是一个分支的名称，它是git默认给你创建的本地分支的名称，你可以使用git branch命令来查看或修改你的本地分支的名称。\nReferences.\n[1]上传文件到gitee\nhttps://blog.csdn.net/fayoung3568/article/details/119488325\n[2] git pull and git pull \u0026ndash;rebase\nhttps://www.bilibili.com/video/BV1dH4y1g7tn/?vd_source=d7d8561214ca72d815e8ee788ea8c86b\n","date":"2025-07-08T02:15:15+08:00","permalink":"https://etherealzoom.github.io/blog/p/git_use/","title":"Git_Use"},{"content":"Hugo学习记录 对于main文件夹和theme文件夹的优先级 main文件夹里面的文件优先级最高，如果main中有文件的层级与在theme中一致，那么会优先采取main中的设置。 所以为了防止theme中的源文件被修改，通常会复制一份到main文件中进行修改，这样如果出问题了，还有后悔药吃。\nHugo optimization 手记 修正时间 存在文章时间显示错误 Jul 07, 2025 -\u0026gt; 显示为 Jul 07, 80815\n在netlify.toml文件夹中添加：\n[context.production] command = \u0026#34;cd exampleSite \u0026amp;\u0026amp; hugo --gc --themesDir ../.. -b ${URL}\u0026#34; [context.production.environment] HUGO_ENV = \u0026#34;production\u0026#34; TZ = \u0026#34;/usr/share/ZZHAO/PRC\u0026#34; GitHub action 需要到github账户的developer生成TOKEN（目前是有限期一年） 然后到blog的main仓库的设置添加token并命名为TOKEN，这是因为在本地文件的yaml文件里面的名字是TOKEN，这样可以不改此文件。 在hugo主文件创建一个.github/workflows/xxxx.yaml文件，将以下内容复制进去: Details name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy 当有新文章后，在本地main推送上github，不是在那个public的文件 推送上去之后，会自动GitHub Actions，修改blog网页的仓库，进而修改个人博客内容。 Github action的好处是，不需要在public的文件夹内提交到GitHub上了，只需要在main文件夹即可。 hugo-stack 设置双列Links 在VSCode里面搜索 custom.scss 文件，然后添加下面代码即可\n@media (min-width: 1024px) { .article-list--compact.links { display: grid; grid-template-columns: 1fr 1fr; background: none; box-shadow: none; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; border-radius: 10px; \u0026amp;:nth-child(odd) { margin-right: 8px; } } } } hugo need install weight opengraph 这部分是用来配置 Open Graph协议 的，它能让你自定义当网站链接被分享到社交媒体（如 Twitter, Facebook, Telegram 等）时，显示的预览卡片样式。 twitter: site: 在这里填写你的 Twitter 用户名（例如 @hugo_rocks）。当你的文章被分享时，卡片上会显示 \u0026ldquo;via @你的用户名\u0026rdquo;。 card: 设置 Twitter 卡片的样式。 summary_large_image: 显示一张大的特色图片，下方是标题和描述（推荐）。 summary: 显示一张小方形图片，标题和描述在右侧 defaultImage 这里用来设置一个默认的社交分享图片。 如果某篇文章没有指定自己的特色图片（featured_image），那么当这篇文章被分享时，就会使用这里设置的默认图片。 opengraph: enabled: false 设为 true 来启用这个功能。 local: false 如果你的默认图片存放在 Hugo 网站的 static 文件夹下，就设为 true。如果图片是通过一个完整的 URL 链接引用的，就设为 false： src: 填写图片的路径或完整的 URL。 如果 local: true，这里填相对路径，如 images/default-cover.jpg。 如果 local: false，这里填完整 URL，如 https://example.com/images/default-cover.jpg。 剔除中英文模式，只留下一种 将整个Blog风格统一化，左侧边栏使用英文标注各个page\n保留默认浅色/深色模式 保留原本的，不用多加颜色的，不过可以微调浅色和深色的色调，加强文字背景对比度\n改善白天模式可读性 在Stack以及很多主题中，主题文件夹下的assets/scss下都提供了一个供用户自定义的custom.scss文件。 将下面代码块复制到custom.scss文件中，会对比度会更高，看得会更清晰。\n:root { --body-background: #EBEBEB; --accent-color: #1B365D; --accent-color-darker: #202A44; --accent-color-text: #FFF; --body-text-color: #202A44; } :root { --card-background: #FFF; --card-background-selected: #EBEBEB; --card-text-color-main: #202A44; --card-text-color-secondary: #53565A; --card-text-color-tertiary: #888B8D; } References.\noxidane-uni的博客\n更改白天/黑夜模式图标 观察网页的CSS可以发现：深色模式下图标的切换就是“一个显示，一个隐藏”，在相关文件中指定该用的图标即可。 在tabler下载\u0026quot;sun-high\u0026quot;和\u0026quot;moon-stars\u0026quot;这两个图标，好看。 作者将黑白开关做在了侧边栏里，因而直接在有关的 .\\assets\\scss\\partials\\sidebar.scss和\\layouts\\partials\\sidebar\\left.html里指定图标即可:\n(1) 在**.\\assets\\scss\\partials\\sidebar.scss**中，修改代码为下面这样：\nDetails [data-scheme=\u0026#34;dark\u0026#34;] { #dark-mode-toggle { color: var(--accent-color); font-weight: 700; .icon-tabler-sun-high { display: none; } .icon-tabler-moon-stars { display: unset; } } } #dark-mode-toggle { margin-top: auto; color: var(--body-text-color); display: flex; align-items: center; cursor: pointer; gap: var(--menu-icon-separation); .icon-tabler-moon-stars { display: none; } } (2)在**\\layouts\\partials\\sidebar\\left.html**中，修改代码为下面这样，用于修改图标\nDetails {{ if (default false .Site.Params.colorScheme.toggle) }} \u0026lt;li id=\u0026#34;dark-mode-toggle\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;sun-high\u0026#34; }} {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;moon-stars\u0026#34; }} \u0026lt;span\u0026gt;{{ T \u0026#34;darkMode\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; {{ end }} (3)修改白天/黑夜模式的文字 \\i18n\\zh-cn.yaml中修改即可\n(4)解决无论浅色深色都只有深色模式显示的问题\n第一步修改 left.html\n增加浅色深色变化项目\nDetails //修改前 {{ if (default false .Site.Params.colorScheme.toggle) }} \u0026lt;li id=\u0026#34;dark-mode-toggle\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;sun-high\u0026#34; }} {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;moon-stars\u0026#34; }} \u0026lt;span\u0026gt;{{ T \u0026#34;darkMode\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; //修改后 {{ if (default false .Site.Params.colorScheme.toggle) }} \u0026lt;li id=\u0026#34;dark-mode-toggle\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;sun-high\u0026#34; }} {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;moon-stars\u0026#34; }} \u0026lt;!-- \u0026lt;span\u0026gt;{{ T \u0026#34;darkMode\u0026#34; }}\u0026lt;/span\u0026gt; --\u0026gt; \u0026lt;span class=\u0026#34;label-light\u0026#34;\u0026gt;{{ T \u0026#34;lightMode\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;label-dark\u0026#34;\u0026gt;{{ T \u0026#34;darkMode\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; 第二步修改 sidebar.scss\n增加注释内容，达到在深色浅色不同模式下，隐藏显示不同的东西\nDetails [data-scheme=\u0026#34;dark\u0026#34;] { #dark-mode-toggle { color: var(--accent-color); font-weight: 700; .icon-tabler-sun-high { display: none; } .icon-tabler-moon-stars { display: unset; } /* 在暗色模式下，隐藏“浅色模式”的文字 */ .label-light { display: none; } /* 在暗色模式下，显示“暗色模式”的文字 */ .label-dark { display: unset; } } } #dark-mode-toggle { margin-top: auto; color: var(--body-text-color); display: flex; align-items: center; cursor: pointer; gap: var(--menu-icon-separation); .icon-tabler-moon-stars { display: none; } /* 在亮色模式下，隐藏“暗色模式”的文字 */ .label-dark { display: none; } } 添加content折叠功能 Create a shortcode in /layouts/shortcodes/details.html\n\u0026lt;details\u0026gt; \u0026lt;summary\u0026gt;{{ (.Get 0) | markdownify }}\u0026lt;/summary\u0026gt; {{ .Inner | markdownify }} \u0026lt;/details\u0026gt; Then this shortcode can be used inside the content file, in markdown, in the following way: Details 折叠压缩\nReferences. content_clapse\nmacOS 风格的代码块 在 assets/scss/partials/layout/article.scss，找到 .highlight 部分并修改成如下:\n.highlight { background-color: var(--pre-background-color); padding: var(--card-padding); position: relative; border-radius: 10px; max-width: 100% !important; margin: 0 !important; box-shadow: var(--shadow-l1) !important; 创建 assets/img/code-header.svg 文件，编辑输入：\n\u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; version=\u0026#34;1.1\u0026#34; x=\u0026#34;0px\u0026#34; y=\u0026#34;0px\u0026#34; width=\u0026#34;450px\u0026#34; height=\u0026#34;130px\u0026#34;\u0026gt; \u0026lt;ellipse cx=\u0026#34;65\u0026#34; cy=\u0026#34;65\u0026#34; rx=\u0026#34;50\u0026#34; ry=\u0026#34;52\u0026#34; stroke=\u0026#34;rgb(220,60,54)\u0026#34; stroke-width=\u0026#34;2\u0026#34; fill=\u0026#34;rgb(237,108,96)\u0026#34;/\u0026gt; \u0026lt;ellipse cx=\u0026#34;225\u0026#34; cy=\u0026#34;65\u0026#34; rx=\u0026#34;50\u0026#34; ry=\u0026#34;52\u0026#34; stroke=\u0026#34;rgb(218,151,33)\u0026#34; stroke-width=\u0026#34;2\u0026#34; fill=\u0026#34;rgb(247,193,81)\u0026#34;/\u0026gt; \u0026lt;ellipse cx=\u0026#34;385\u0026#34; cy=\u0026#34;65\u0026#34; rx=\u0026#34;50\u0026#34; ry=\u0026#34;52\u0026#34; stroke=\u0026#34;rgb(27,161,37)\u0026#34; stroke-width=\u0026#34;2\u0026#34; fill=\u0026#34;rgb(100,200,86)\u0026#34;/\u0026gt; \u0026lt;/svg\u0026gt; 最后在 assets/scss/custom.scss 添加代码块的样式：\n// 为代码块顶部添加 macos 样式 .article-content { .highlight:before { content: \u0026#34;\u0026#34;; display: block; background: url(/img/code-header.svg); height: 25px; width: 100%; background-size: 52px; background-repeat: no-repeat; margin-top: -10px; margin-bottom: 0; } } 可能存在行数的问题，可以取消行数：\n打开hugo.yaml，修改highlight部分为lineNos: false\nEDN.hugo 优化 时间格式format为jul 7, 2025 将link显示改成2栏 设置自己的blog头像、网页小图标 设置Copyright © 2025 etherealzoom 剔除中英文模式，留中文模式作为默认，后续自己添加内容 about部分可以中英文，一式两份 保留默认colorScheme，白天/黑夜模式 改善白天模式的可读性 更改白天/黑夜模式图标 新建一个repository作为图床 开启GitHub Actions 评论系统推荐giscus, better than utyerance评论系统 加音乐播放器：Aplayer + MetingJs(优先级很低) 添加content折叠功能 macOS 风格的代码块 References.Blog\n第三夏尔 | Third Shire ","date":"2025-07-07T20:16:23+08:00","permalink":"https://etherealzoom.github.io/blog/p/hugo-depoly/","title":"Hugo Depoly"}]