[{"content":"疑惑 Pytorch平台上对RWKV的困惑度计算模块进行量化的经历 Q:更稳妥的方式是在模型加载和量化后，将整个模型转为float32，再量化后转换成float32的目的是什么呢，这样不是把原来量化好的给毁了吗\nA：\npytorch上量化做了什么 当调用torch.quantization.quantize_dynamic时，PyTorch并不仅仅是把权重张量的数据类型（dtype）改了一下。它做了一件更根本的事：它将模型中的标准nn.Linear层替换成了一个全新的、专门的模块，叫做DynamicQuantizedLinear。\n在这个新的DynamicQuantizedLinear模块内部，权重确实被压缩并以**torch.qint8（8位整型）**的格式存储了起来。\n同时，这个模块还保存了将这些INT8整数反量化回浮点数所需的缩放因子（scale）和零点（zero-point）（它们是浮点数）。\n.to(torch.float32) 到底做了什么？ 当您对一个模型调用.to(dtype)方法时，PyTorch会遍历模型的所有参数（parameters）和缓冲区（buffers），并尝试将它们的类型转换为您指定的dtype。\n这里的关键在于：.to() 方法只会转换浮点类型的张量（例如 bfloat16, float16, float64）。\n它会跳过那些已经是**整型（Integer）**的张量，比如我们量化后存储为torch.qint8的权重。 因此，INT8权重本身保持不变，量化的成果得以保留。\n那我们为什么要执行这个转换呢？ 这个操作的目的，正是为了解决您在上一个问题中遇到的 RuntimeError: expected scalar type Float but found BFloat16 错误。\n让我们回顾一下当时的情况：\n(1)原始模型：您加载模型时，因为设置了'dataformat': 'bf16'，所以模型中所有的浮点参数都是bfloat16类型。这包括Embedding层、LayerNorm层，以及Linear层的权重和偏置。 (2)量化之后：quantize_dynamic函数只替换了Linear层。但是，模型中的其他层（如Embedding和LayerNorm）的参数依然是bfloat16类型。 (3)冲突发生：当数据流经模型时，Embedding层输出一个bfloat16的张量，这个张量被送入到我们新替换的DynamicQuantizedLinear层。然而，这个量化层的CPU后端实现期望接收一个标准的float32张量作为输入，而不是bfloat16。于是，类型不匹配，程序崩溃。\n所以，调用model.to(torch.float32)的真正目的，是将模型中除了INT8权重之外的所有其他浮点参数和缓冲区**（比如仍然是bfloat16格式的Embedding层或LayerNorm层）全部统一转换为标准的float32格式。\n总结一下，这个操作可以理解为一次“内务整理”：\nINT8权重： untouchable，保持量化状态。 其他所有浮点部分（bfloat16）：全部转换为float32。 这样一来，整个模型的数据流就统一了：非量化层输出float32张量，量化层接收float32张量，内部进行计算，从而完美解决了类型冲突的问题，同时保留了INT8量化带来的内存节省优势。\npython中的enumereate (1) 没有 enumerate 的情况 您的原始循环是这样的： for begin_loc in tqdm(range(0, 1536, 512)):\n这个循环会执行三次，在每一次循环中：\n第1次循环：begin_loc 的值是 0 第2次循环：begin_loc 的值是 512 第3次循环：begin_loc 的值是 1024 可以看到，这个循环只提供了一个变量 begin_loc。\n(2) 加入 enumerate 之后的情况\n您修改后的正确循环是这样的： for idx, begin_loc in enumerate(tqdm(range(0, 1536, 512))):\n这个循环同样会执行三次，在每一次循环中：\n第1次循环：idx 的值是 0，begin_loc 的值是 0 第2次循环：idx 的值是 1，begin_loc 的值是 512 第3次循环：idx 的值是 2，begin_loc 的值是 1024 结论 通过对比可以清晰地看到：\n核心变量 begin_loc 的值完全没变：在每次对应的循环中，begin_loc 得到的值和原来一模一样，都是 0, 512, 1024, ...。所以您循环内部使用 begin_loc 的所有逻辑都不会受到任何影响。\n循环次数完全没变：range 函数生成多少个数字，循环就会执行多少次。enumerate 不会增加或减少循环的次数。\n唯一的改变：enumerate 只是为您额外提供了一个从0开始的计数器变量 idx。这个变量正是您在 print 语句中所需要的，它解决了 NameError，并且让您能方便地知道当前是第几步循环。\n所以，加入 enumerate 是一个纯粹的“增强”操作，它在不干扰原有功能的基础上，安全地添加了您需要的新功能（即步数索引）。这是在Python中进行带索引循环的标准且推荐的做法。\n如果计算RWKV中的困惑度的呢 核心思想是**“对比每一个字（Token）的输出与下一个真实字的关系”**\nRWKV的困惑度计算的核心代码（先计算loss）：\nwith torch.no_grad(): logits, state = model.forward_parallel_slices(input, state, slice_len=1024) loss = F.cross_entropy(logits.view(-1, logits.size(-1)), output) 只进行推理计算，不计算梯度 二者有什么区别吗 训练是为了教会模型，而推理是为了使用已经教好的模型\n当然有，这两种模式在计算流程、资源消耗和最终目的上有着本质的区别。\n简单来说，训练是为了教会模型，而推理是为了使用已经教好的模型。\n特性 (Characteristic) 训练模式 (Training Mode) 推理模式 (Inference Mode) 核心目标 学习和优化模型参数（权重），让模型变得更“聪明”。 使用已训练好的模型对新数据进行预测和评估。 计算流程 前向传播 + 反向传播 (Forward Pass + Backward Pass) 仅有前向传播 (Forward Pass ONLY) 梯度计算 必须计算梯度。梯度是反向传播的核心，它告诉每个权重应该如何调整才能减小误差（loss）。 完全不需要计算梯度。因为模型参数是固定的，我们不打算更新它，所以计算梯度就成了不必要的开销。 内存占用 高。为了能够进行反向传播，PyTorch需要构建一个“计算图”，并保存所有中间步骤的计算结果（激活值）。这会占用大量内存。 低。因为不需要反向传播，PyTorch可以用完一个中间结果后立即丢弃，无需为计算图保存任何额外信息，大大节省了内存。 计算速度 慢。既要跑一遍前向传播，又要跑一遍更复杂的反向传播。 快。只执行一次前向传播，省去了所有与梯度相关的计算。 在PyTorch中的体现 默认模式。执行loss.backward()和optimizer.step()来更新权重。 使用with torch.no_grad():代码块包裹。同时常配合model.eval()来关闭Dropout等只在训练时使用的层。 因此，在计算困惑度时，使用 with torch.no_grad(): 是一个重要的优化步骤，它能让评估过程变得更快、更节省资源。\n","date":"2025-07-09T23:06:03+08:00","permalink":"https://etherealzoom.github.io/blog/p/quantization/","title":"Quantization"},{"content":"玄戒O1芯片架构 芯片基础 CPU: 基于ARMv9.2指令集架构的Cortex CPU集群\nGPU: ARM的Immortalis GPU IP\n系统级设计: 玄戒O1芯片的互联技术采用了ARM的CoreLink系统IP CPU架构 十核四丛集设计\nCortex-X925 3.9GHz *2\n-\u0026gt; 最高主频达3.9GHz，表现超越业界标准设计，是小米玄戒团队通过大量创新和数百次版图迭代优化的结果\nCortex-A725 3.4GHz *4\nCortex-A725 1.9GHz *2\nCortex-A520 1.8GHz *2\nUltra-fast Micro Control Unit-on chip\n在硬件上实现对各个核的调度\n缓存结构\n数据保存的位置离使用的位置越近，性能越高，降低延迟核功耗\n玄戒团队三个提高主频的方法\n(1) 优化供电网络设计：边缘供电+空间组网\n玄戒团队将主供电单元移到SoC两侧，缩短逻辑单元的物理距离\n(2) 自研多种3nm标准单元Std Cell\n(3) 电路版图全链路迭代优化+人工精调\nNPU 玄戒O1内置6核NPU，集成Scalar标量加速器、Vector矢量加速器和Tensor张量加速器，NPU算力可达44 TOPS ，支持多算法并行计算。在拍摄时，可并行“拍照”和“预览”算法，不仅满足计算摄影的影像算法需求，更针对小米自有的端侧模型进行了硬件底层的深度定制。\n配合全新第三代小米端侧模型，AI处理速度更快，同时功耗更低，使手机在智能语音助手、图像识别、智能场景优化等AI应用方面表现更加出色。\nISP xiaomi自研第四代ISP单元\nReferences.\n[1] 极客湾\n[2] 老石谈芯\n","date":"2025-07-09T21:56:37+08:00","permalink":"https://etherealzoom.github.io/blog/p/xringo1/","title":"XringO1"},{"content":"命令\n# 初始化一个本地仓库 git init # 添加所有文件到暂存区 git add . # 提交暂存区的文件到本地仓库，并添加一条提交信息 git commit -m \u0026#34;first commit\u0026#34; # 添加一个远程仓库的地址，命名为origin git remote add origin https://github.com/user/repo.git # 将本地仓库的内容推送到远程仓库的master分支 git push -u origin master #查看当前缓存区的all内容 git ls-files #delete a cangku 的所有提交记录 *** - 创建一个新的孤立分支，并切换到该分支：`git checkout --orphan latest_branch` - 删除原来的master分支：`git branch -D master` - 重命名当前分支为master：`git branch -m master` - 强制推送当前分支到远程仓库：`git push -f origin master` - **该操作不可逆 *** #查看当前分支数量以及名称 git branch #怎么上传一个.git所在文件中的文件夹里面的所有文件 **添加子文件夹及其内容至暂存区**： 使用`git add`命令，配合递归通配符`**`来添加子文件夹及其内部的所有文件。假设子文件夹名为`subfolder`，执行： git add subfolder/** 用户资料部分\n//显示差异摘要（每个提交修改的文件及行数统计）： git log --author=\u0026#34;当前用户名\u0026#34; --stat //以图形化方式展示分支历史 git log --author=\u0026#34;当前用户名\u0026#34; --graph //- 显示完整的提交消息： git log --author=\u0026#34;当前用户名\u0026#34; --pretty=format:\u0026#34;%h %s\u0026#34; git文件恢复 //没有add的文件恢复，一个一个恢复 git checkout \u0026lt;文件名\u0026gt; //有add，无commit git checkout \u0026lt;commit id\u0026gt; 文件名 #id使用git log查看 //已经commit git checkout \u0026lt;commit id\u0026gt; 文件名 知识点\n哈希值 f7cafda (HEAD -\u0026gt; master) 重新提交有关tc264开发的相关资料 d01e0e1 提交有关tc264开发的相关资料 前面的一串数字是什么意思 答： 前面的一串数字是哈希值，它是一个由 40 个十六进制字符组成的字符串，用来唯一标识每一次提交。Git 通过计算提交的内容、作者、日期等信息的 SHA-1 散列值来生成这个哈希值 (HEAD -\u0026gt; master)是什么 答： (HEAD -\u0026gt; master)是Git中的一种表示方式，它表示HEAD指向master分支，而master分支指向最新的提交。HEAD是一个特殊的引用，它总是指向当前的提交，而master是一个普通的分支，它可以指向任何一个提交。当你在master分支上进行提交时，HEAD和master都会移动到最新的提交上(https://zhuanlan.zhihu.com/p/40001702) [1]关于Git分支中HEAD和Master的理解(https://zhuanlan.zhihu.com/p/40001702)[: 关于Git分支中HEAD和Master的理解 - 知乎](https://www.jianshu.com/p/4219b6f62ce3) 3）解释git push -u origin master\n- git是一个分布式版本控制系统，可以用来管理和协作项目的源代码。 - push是一个git子命令，它的作用是将本地仓库的内容推送到远程仓库的指定分支。 - -u是一个参数，它的全称是–set-upstream，它的作用是设置默认的上游分支，也就是当你在本地仓库执行git pull或git push时，不需要指定远程仓库和分支名，git会自动使用你设置的上游分支。 - origin是一个远程仓库的名称，它是git默认给你添加的远程仓库的别名，你可以使用git remote命令来查看或修改你的远程仓库的名称。 - master是一个分支的名称，它是git默认给你创建的本地分支的名称，你可以使用git branch命令来查看或修改你的本地分支的名称。 4）上传文件到gitee https://blog.csdn.net/fayoung3568/article/details/119488325\n5）git pull and git pull \u0026ndash;rebase https://www.bilibili.com/video/BV1dH4y1g7tn/?vd_source=d7d8561214ca72d815e8ee788ea8c86b\n","date":"2025-07-08T02:15:15+08:00","permalink":"https://etherealzoom.github.io/blog/p/git_use/","title":"Git_use"},{"content":"Hugo学习记录 对于main文件夹和theme文件夹的优先级 main文件夹里面的文件优先级最高，如果main中有文件的层级与在theme中一致，那么会优先采取main中的设置。 所以为了防止theme中的源文件被修改，通常会复制一份到main文件中进行修改，这样如果出问题了，还有后悔药吃。\nHugo optimization 手记 修正时间 存在文章时间显示错误 Jul 07, 2025 -\u0026gt; 显示为 Jul 07, 80815\n在netlify.toml文件夹中添加：\n[context.production] command = \u0026#34;cd exampleSite \u0026amp;\u0026amp; hugo --gc --themesDir ../.. -b ${URL}\u0026#34; [context.production.environment] HUGO_ENV = \u0026#34;production\u0026#34; TZ = \u0026#34;/usr/share/ZZHAO/PRC\u0026#34; GitHub action 需要到github账户的developer生成TOKEN（目前是有限期一年） 然后到blog的main仓库的设置添加token并命名为TOKEN，这是因为在本地文件的yaml文件里面的名字是TOKEN，这样可以不改此文件。 在hugo主文件创建一个.github/workflows/xxxx.yaml文件，将以下内容复制进去: Details name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy 当有新文章后，在本地main推送上github，不是在那个public的文件 推送上去之后，会自动GitHub Actions，修改blog网页的仓库，进而修改个人博客内容。 Github action的好处是，不需要在public的文件夹内提交到GitHub上了，只需要在main文件夹即可。 hugo-stack 设置双列Links 在VSCode里面搜索 custom.scss 文件，然后添加下面代码即可\n@media (min-width: 1024px) { .article-list--compact.links { display: grid; grid-template-columns: 1fr 1fr; background: none; box-shadow: none; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; border-radius: 10px; \u0026amp;:nth-child(odd) { margin-right: 8px; } } } } hugo need install weight opengraph 这部分是用来配置 Open Graph协议 的，它能让你自定义当网站链接被分享到社交媒体（如 Twitter, Facebook, Telegram 等）时，显示的预览卡片样式。 twitter: site: 在这里填写你的 Twitter 用户名（例如 @hugo_rocks）。当你的文章被分享时，卡片上会显示 \u0026ldquo;via @你的用户名\u0026rdquo;。 card: 设置 Twitter 卡片的样式。 summary_large_image: 显示一张大的特色图片，下方是标题和描述（推荐）。 summary: 显示一张小方形图片，标题和描述在右侧 defaultImage 这里用来设置一个默认的社交分享图片。 如果某篇文章没有指定自己的特色图片（featured_image），那么当这篇文章被分享时，就会使用这里设置的默认图片。 opengraph: enabled: false 设为 true 来启用这个功能。 local: false 如果你的默认图片存放在 Hugo 网站的 static 文件夹下，就设为 true。如果图片是通过一个完整的 URL 链接引用的，就设为 false： src: 填写图片的路径或完整的 URL。 如果 local: true，这里填相对路径，如 images/default-cover.jpg。 如果 local: false，这里填完整 URL，如 https://example.com/images/default-cover.jpg。 剔除中英文模式，只留下一种 将整个Blog风格统一化，左侧边栏使用英文标注各个page\n保留默认浅色/深色模式 保留原本的，不用多加颜色的，不过可以微调浅色和深色的色调，加强文字背景对比度\n改善白天模式可读性 在Stack以及很多主题中，主题文件夹下的assets/scss下都提供了一个供用户自定义的custom.scss文件。 将下面代码块复制到custom.scss文件中，会对比度会更高，看得会更清晰。\n:root { --body-background: #EBEBEB; --accent-color: #1B365D; --accent-color-darker: #202A44; --accent-color-text: #FFF; --body-text-color: #202A44; } :root { --card-background: #FFF; --card-background-selected: #EBEBEB; --card-text-color-main: #202A44; --card-text-color-secondary: #53565A; --card-text-color-tertiary: #888B8D; } References.\noxidane-uni的博客\n更改白天/黑夜模式图标 观察网页的CSS可以发现：深色模式下图标的切换就是“一个显示，一个隐藏”，在相关文件中指定该用的图标即可。 在tabler下载\u0026quot;sun-high\u0026quot;和\u0026quot;moon-stars\u0026quot;这两个图标，好看。 作者将黑白开关做在了侧边栏里，因而直接在有关的 .\\assets\\scss\\partials\\sidebar.scss和\\layouts\\partials\\sidebar\\left.html里指定图标即可:\n(1) 在**.\\assets\\scss\\partials\\sidebar.scss**中，修改代码为下面这样：\nDetails [data-scheme=\u0026#34;dark\u0026#34;] { #dark-mode-toggle { color: var(--accent-color); font-weight: 700; .icon-tabler-sun-high { display: none; } .icon-tabler-moon-stars { display: unset; } } } #dark-mode-toggle { margin-top: auto; color: var(--body-text-color); display: flex; align-items: center; cursor: pointer; gap: var(--menu-icon-separation); .icon-tabler-moon-stars { display: none; } } (2)在**\\layouts\\partials\\sidebar\\left.html**中，修改代码为下面这样，用于修改图标\nDetails {{ if (default false .Site.Params.colorScheme.toggle) }} \u0026lt;li id=\u0026#34;dark-mode-toggle\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;sun-high\u0026#34; }} {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;moon-stars\u0026#34; }} \u0026lt;span\u0026gt;{{ T \u0026#34;darkMode\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; {{ end }} (3)修改白天/黑夜模式的文字 \\i18n\\zh-cn.yaml中修改即可\n(4)解决无论浅色深色都只有深色模式显示的问题\n第一步修改 left.html\n增加浅色深色变化项目\nDetails //修改前 {{ if (default false .Site.Params.colorScheme.toggle) }} \u0026lt;li id=\u0026#34;dark-mode-toggle\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;sun-high\u0026#34; }} {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;moon-stars\u0026#34; }} \u0026lt;span\u0026gt;{{ T \u0026#34;darkMode\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; //修改后 {{ if (default false .Site.Params.colorScheme.toggle) }} \u0026lt;li id=\u0026#34;dark-mode-toggle\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;sun-high\u0026#34; }} {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;moon-stars\u0026#34; }} \u0026lt;!-- \u0026lt;span\u0026gt;{{ T \u0026#34;darkMode\u0026#34; }}\u0026lt;/span\u0026gt; --\u0026gt; \u0026lt;span class=\u0026#34;label-light\u0026#34;\u0026gt;{{ T \u0026#34;lightMode\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;label-dark\u0026#34;\u0026gt;{{ T \u0026#34;darkMode\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; 第二步修改 sidebar.scss\n增加注释内容，达到在深色浅色不同模式下，隐藏显示不同的东西\nDetails [data-scheme=\u0026#34;dark\u0026#34;] { #dark-mode-toggle { color: var(--accent-color); font-weight: 700; .icon-tabler-sun-high { display: none; } .icon-tabler-moon-stars { display: unset; } /* 在暗色模式下，隐藏“浅色模式”的文字 */ .label-light { display: none; } /* 在暗色模式下，显示“暗色模式”的文字 */ .label-dark { display: unset; } } } #dark-mode-toggle { margin-top: auto; color: var(--body-text-color); display: flex; align-items: center; cursor: pointer; gap: var(--menu-icon-separation); .icon-tabler-moon-stars { display: none; } /* 在亮色模式下，隐藏“暗色模式”的文字 */ .label-dark { display: none; } } 添加content折叠功能 Create a shortcode in /layouts/shortcodes/details.html\n\u0026lt;details\u0026gt; \u0026lt;summary\u0026gt;{{ (.Get 0) | markdownify }}\u0026lt;/summary\u0026gt; {{ .Inner | markdownify }} \u0026lt;/details\u0026gt; Then this shortcode can be used inside the content file, in markdown, in the following way: Details 折叠压缩\nReferences. content_clapse\nmacOS 风格的代码块 在 assets/scss/partials/layout/article.scss，找到 .highlight 部分并修改成如下:\n.highlight { background-color: var(--pre-background-color); padding: var(--card-padding); position: relative; border-radius: 10px; max-width: 100% !important; margin: 0 !important; box-shadow: var(--shadow-l1) !important; 创建 assets/img/code-header.svg 文件，编辑输入：\n\u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; version=\u0026#34;1.1\u0026#34; x=\u0026#34;0px\u0026#34; y=\u0026#34;0px\u0026#34; width=\u0026#34;450px\u0026#34; height=\u0026#34;130px\u0026#34;\u0026gt; \u0026lt;ellipse cx=\u0026#34;65\u0026#34; cy=\u0026#34;65\u0026#34; rx=\u0026#34;50\u0026#34; ry=\u0026#34;52\u0026#34; stroke=\u0026#34;rgb(220,60,54)\u0026#34; stroke-width=\u0026#34;2\u0026#34; fill=\u0026#34;rgb(237,108,96)\u0026#34;/\u0026gt; \u0026lt;ellipse cx=\u0026#34;225\u0026#34; cy=\u0026#34;65\u0026#34; rx=\u0026#34;50\u0026#34; ry=\u0026#34;52\u0026#34; stroke=\u0026#34;rgb(218,151,33)\u0026#34; stroke-width=\u0026#34;2\u0026#34; fill=\u0026#34;rgb(247,193,81)\u0026#34;/\u0026gt; \u0026lt;ellipse cx=\u0026#34;385\u0026#34; cy=\u0026#34;65\u0026#34; rx=\u0026#34;50\u0026#34; ry=\u0026#34;52\u0026#34; stroke=\u0026#34;rgb(27,161,37)\u0026#34; stroke-width=\u0026#34;2\u0026#34; fill=\u0026#34;rgb(100,200,86)\u0026#34;/\u0026gt; \u0026lt;/svg\u0026gt; 最后在 assets/scss/custom.scss 添加代码块的样式：\n// 为代码块顶部添加 macos 样式 .article-content { .highlight:before { content: \u0026#34;\u0026#34;; display: block; background: url(/img/code-header.svg); height: 25px; width: 100%; background-size: 52px; background-repeat: no-repeat; margin-top: -10px; margin-bottom: 0; } } 可能存在行数的问题，可以取消行数：\n打开hugo.yaml，修改highlight部分为lineNos: false\nEDN.hugo 优化 时间格式format为jul 7, 2025 将link显示改成2栏 设置自己的blog头像、网页小图标 设置Copyright © 2025 etherealzoom 剔除中英文模式，留中文模式作为默认，后续自己添加内容 about部分可以中英文，一式两份 保留默认colorScheme，白天/黑夜模式 改善白天模式的可读性 更改白天/黑夜模式图标 新建一个repository作为图床 开启GitHub Actions 评论系统推荐giscus, better than utyerance评论系统 加音乐播放器：Aplayer + MetingJs(优先级很低) 添加content折叠功能 macOS 风格的代码块 References.Blog\n第三夏尔 | Third Shire ","date":"2025-07-07T20:16:23+08:00","permalink":"https://etherealzoom.github.io/blog/p/hugo-depoly/","title":"Hugo Depoly"}]